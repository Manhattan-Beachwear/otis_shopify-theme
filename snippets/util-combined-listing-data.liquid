{%- doc -%}
  Utility snippet to calculate sorted swatches and first variant data for combined listings.
  This consolidates the logic used by both product card image rendering and swatches rendering.

  @param {object} product_resource - The product object
  @param {object} combined_listings_metafield - The combined listing metafield
  @param {boolean} enable_combined - Whether combined listings are enabled

  Output variables:
  - has_combined_listing: Boolean indicating if this product has combined listings
  - sorted_swatches_data: Array of swatch data strings (product_id|product_type|variant_id|product_url|product_title|has_swatch|color_value|color_option|is_current|available)
  - first_variant: The variant object for the first alphabetical swatch
  - first_product_obj: The product object for the first alphabetical swatch (from metafield)
  - first_variant_image: The featured image for the first variant
  - first_variant_url: The URL for the first variant
{%- enddoc -%}

{% liquid
  # Initialize output variables
  assign has_combined_listing = false
  assign sorted_swatches_data = ''
  assign first_variant = blank
  assign first_product_obj = blank
  assign first_variant_image = blank
  assign first_variant_url = blank
  
  # Always get metafield directly from product_resource to ensure it's accessible
  # The passed parameter might not be accessible the same way inside liquid blocks
  assign combined_listings_metafield = product_resource.metafields.custom.combined_listing
  
  # Check if combined listings are enabled
  if enable_combined
    # Track the source product that owns the metafield (for adding it to the list later)
    assign source_metafield_product = product_resource
    
    # If metafield still not found, check if product is referenced in another product's metafield
    if combined_listings_metafield == blank or combined_listings_metafield.value == blank
      for all_product in collections.all.products
        if all_product.id != product_resource.id
          assign check_metafield = all_product.metafields.custom.combined_listing
          if check_metafield != blank and check_metafield.value != blank
            assign current_product_found_in_metafield = false
            for linked_product in check_metafield.value
              assign linked_product_id = linked_product.id
              assign current_product_id = product_resource.id
              assign linked_product_id_as_string = linked_product_id | append: ''
              assign current_product_id_as_string = current_product_id | append: ''
              if linked_product_id == current_product_id or linked_product_id_as_string == current_product_id_as_string
                assign current_product_found_in_metafield = true
                assign combined_listings_metafield = check_metafield
                assign source_metafield_product = all_product
                break
              endif
            endfor
            if current_product_found_in_metafield
              break
            endif
          endif
        endif
      endfor
    endif
    
    # Check if we have a valid combined listing metafield
    # Match the logic from variant-combined-listing-picker: directly iterate to detect products
    assign metafield_has_products = false
    assign metafield_value_count = 0
    
    if combined_listings_metafield != blank and combined_listings_metafield.value != blank
      # Try iterating directly - if we can iterate, we have products
      for test_product in combined_listings_metafield.value
        assign metafield_has_products = true
        assign metafield_value_count = metafield_value_count | plus: 1
      endfor
    endif
    
    # Set has_combined_listing if we found products
    if metafield_has_products
      assign has_combined_listing = true
    endif
    
    # Collect all products from metafield (current + related) with their data
    # Only process if we have a combined listing
    if has_combined_listing
      # Match the logic from variant-combined-listing-picker: process all products from metafield, then always add current product
      assign all_products_data = ''
      assign processed_product_ids = ''
      
      # Process products directly from the metafield (same as variant-combined-listing-picker)
      # Use the metafield value we already verified exists
      if combined_listings_metafield != blank and combined_listings_metafield.value != blank
      for linked_product in combined_listings_metafield.value
      assign linked_product_id = linked_product.id
      assign current_product_id = product_resource.id
      assign linked_product_id_as_string = linked_product_id | append: ''
      assign current_product_id_as_string = current_product_id | append: ''
      
      # Check if this linked product is already in all_products_data to avoid duplicates
      assign already_added = false
      if all_products_data != ''
        assign all_products_check = all_products_data | split: ','
        for check_item in all_products_check
          assign check_parts = check_item | split: '|'
          if check_parts.size > 0
            assign check_id = check_parts[0] | strip
            assign check_id_as_number = check_id | plus: 0
            if linked_product_id == check_id or linked_product_id == check_id_as_number or linked_product_id_as_string == check_id
              assign already_added = true
              break
            endif
          endif
        endfor
      endif
      
      unless already_added
        if all_products_data == ''
          assign all_products_data = linked_product_id | append: '|linked'
        else
          assign all_products_data = all_products_data | append: ',' | append: linked_product_id | append: '|linked'
        endif
      endunless
    endfor
    endif
    
    # Always add current product explicitly (ensures it's always included, even if already in metafield)
    assign current_product_id_for_data = product_resource.id | append: ''
    if current_product_id_for_data != blank and current_product_id_for_data != ''
      # Check if current product is already in the list
      assign current_already_added = false
      if all_products_data != ''
        assign all_products_check_current = all_products_data | split: ','
        for check_item_current in all_products_check_current
          assign check_parts_current = check_item_current | split: '|'
          if check_parts_current.size > 0
            assign check_id_current = check_parts_current[0] | strip
            assign check_id_current_as_number = check_id_current | plus: 0
            assign current_product_id_str = product_resource.id | append: ''
            if current_product_id_str == check_id_current or product_resource.id == check_id_current or product_resource.id == check_id_current_as_number or current_product_id_str == check_id_current
              assign current_already_added = true
              break
            endif
          endif
        endfor
      endif
      
      unless current_already_added
        if all_products_data == ''
          assign all_products_data = current_product_id_for_data | append: '|current'
        else
          assign all_products_data = all_products_data | append: ',' | append: current_product_id_for_data | append: '|current'
        endif
      endunless
    endif
    
    # If the metafield was found on another product, also add that product (the owner) if not already in list
    # This matches variant-combined-listing-picker behavior
    if source_metafield_product.id != product_resource.id
      assign owner_product_id = source_metafield_product.id | append: ''
      assign owner_already_added = false
      if all_products_data != ''
        assign all_products_check_owner = all_products_data | split: ','
        for check_item_owner in all_products_check_owner
          assign check_parts_owner = check_item_owner | split: '|'
          if check_parts_owner.size > 0
            assign check_id_owner = check_parts_owner[0] | strip
            assign check_id_owner_as_number = check_id_owner | plus: 0
            if owner_product_id == check_id_owner or source_metafield_product.id == check_id_owner or source_metafield_product.id == check_id_owner_as_number
              assign owner_already_added = true
              break
            endif
          endif
        endfor
      endif
      
      unless owner_already_added
        if all_products_data == ''
          assign all_products_data = owner_product_id | append: '|linked'
        else
          assign all_products_data = all_products_data | append: ',' | append: owner_product_id | append: '|linked'
        endif
      endunless
    endif
    
    # Build products array with full data
    assign products_array = all_products_data | split: ','
    assign products_with_data = ''
    
    for product_data in products_array
      if product_data != blank and product_data != ''
        assign product_parts = product_data | split: '|'
        assign product_id_index = 0
        assign product_type_index = 1
        if product_parts.size > 0 and product_parts[0] == blank or product_parts[0] == ''
          assign product_id_index = 1
          assign product_type_index = 2
        endif
        
        if product_parts.size > product_type_index
          assign product_id = product_parts[product_id_index] | strip
          assign product_type = product_parts[product_type_index] | strip
          assign product_type_normalized = product_type | downcase | strip
          
          if product_id == blank or product_id == ''
            if product_type_normalized == 'current'
              assign product_id = product_resource.id
            endif
          endif
          
          assign product_id_as_number = product_id | plus: 0
          
          # Find the product object (match variant-combined-listing-picker logic)
          assign current_product_obj = ''
          assign product_id_as_number = product_id | plus: 0
          assign product_id_str = product_id | append: ''
          assign current_product_id_str = product_resource.id | append: ''
          
          # Check if it's the current product
          if product_id == product_resource.id or product_id_as_number == product_resource.id or product_id_str == current_product_id_str
            assign current_product_obj = product_resource
          else
            # Try to find from metafield first (more reliable)
            if combined_listings_metafield != blank and combined_listings_metafield.value != blank
              for linked_product in combined_listings_metafield.value
                assign linked_product_id = linked_product.id
                assign linked_product_id_str = linked_product_id | append: ''
                if linked_product_id == product_id or linked_product_id == product_id_as_number or linked_product_id_str == product_id_str
                  assign current_product_obj = linked_product
                  break
                endif
              endfor
            endif
            
            # Fallback: Find from collections.all.products
            if current_product_obj == ''
              for all_product in collections.all.products
                assign all_product_id_str = all_product.id | append: ''
                if all_product.id == product_id or all_product.id == product_id_as_number or all_product_id_str == product_id_str
                  assign current_product_obj = all_product
                  break
                endif
              endfor
            endif
          endif
          
          if current_product_obj != ''
            # Use selected_or_first_available_variant for all products
            assign variant_to_display = current_product_obj.selected_or_first_available_variant
            
            # Find color option value with swatch if available
            assign color_option_value = ''
            assign color_option_value_name = ''
            assign color_option_name = ''
            assign has_swatch = false
            
            # Step 1: Check for "color" variant option (case-insensitive)
            for option in current_product_obj.options_with_values
              assign option_name_lower = option.name | downcase
              if option_name_lower == 'color'
                assign color_option_name = option.name
                if option.position == 1
                  assign variant_color_value = variant_to_display.option1
                elsif option.position == 2
                  assign variant_color_value = variant_to_display.option2
                elsif option.position == 3
                  assign variant_color_value = variant_to_display.option3
                else
                  assign variant_color_value = ''
                endif
                
                assign color_option_value_name = variant_color_value
                
                assign swatch_count = option.values | map: 'swatch' | compact | size
                if swatch_count > 0
                  for product_option_value in option.values
                    if product_option_value.variant.id == variant_to_display.id
                      assign color_option_value = product_option_value
                      assign has_swatch = true
                      break
                    endif
                  endfor
                endif
                
                break
              endif
            endfor
            
            # Step 2: If no "color" option found, use first available option name
            if color_option_name == ''
              assign first_option = current_product_obj.options_with_values.first
              if first_option
                assign color_option_name = first_option.name
                if first_option.position == 1
                  assign color_option_value_name = variant_to_display.option1
                elsif first_option.position == 2
                  assign color_option_value_name = variant_to_display.option2
                elsif first_option.position == 3
                  assign color_option_value_name = variant_to_display.option3
                endif
                assign swatch_count = first_option.values | map: 'swatch' | compact | size
                if swatch_count > 0
                  for product_option_value in first_option.values
                    if product_option_value.variant.id == variant_to_display.id
                      assign color_option_value = product_option_value
                      assign has_swatch = true
                      break
                    endif
                  endfor
                endif
              endif
            endif
            
            if color_option_value_name == blank or color_option_value_name == ''
              if variant_to_display.title != blank
                assign color_option_value_name = variant_to_display.title
              else
                assign color_option_value_name = current_product_obj.title
              endif
            endif
            
            if color_option_name == blank or color_option_name == ''
              assign color_option_name = 'Option'
            endif
            
            # Determine if this is the current product by comparing IDs
            assign is_current = 'false'
            assign current_product_id_check = product_resource.id
            assign product_id_check = product_id_as_number
            assign product_id_check_str = product_id_str
            assign current_product_id_check_str = current_product_id_check | append: ''
            if product_id_check == current_product_id_check or product_id_check_str == current_product_id_check_str or product_id == current_product_id_check
              assign is_current = 'true'
            endif
            
            assign product_url_clean = current_product_obj.url
            assign variant_available_string = 'false'
            if variant_to_display.available
              assign variant_available_string = 'true'
            endif
            
            # Ensure product_id is set correctly
            if product_id == blank or product_id == ''
              assign product_id = current_product_obj.id
              assign product_id_as_number = product_id | plus: 0
            endif
            
            # Convert product_id to string
            assign product_id_str = product_id | append: ''
            if product_id_str == blank or product_id_str == ''
              assign product_id_str = current_product_obj.id | append: ''
            endif
            if product_id_str == blank or product_id_str == ''
              assign product_id_str = current_product_obj.id
            endif
            
            # Keep product_type for data structure (but determine is_current by ID comparison)
            assign product_type_str = product_type | append: ''
            assign variant_id_str = variant_to_display.id | append: ''
            assign product_url_str = product_url_clean | append: ''
            assign product_title_str = current_product_obj.title | append: ''
            assign has_swatch_str = has_swatch | append: ''
            assign color_value_str = color_option_value_name | append: ''
            assign color_option_str = color_option_name | append: ''
            assign is_current_str = is_current | append: ''
            assign available_str = variant_available_string | append: ''
            
            # Use product_id_str as final_product_id_str (already set above)
            assign final_product_id_str = product_id_str
            
            assign product_data_string = final_product_id_str | append: '|' | append: product_type_str | append: '|' | append: variant_id_str | append: '|' | append: product_url_str | append: '|' | append: product_title_str | append: '|' | append: has_swatch_str | append: '|' | append: color_value_str | append: '|' | append: color_option_str | append: '|' | append: is_current_str | append: '|' | append: available_str
            
            if products_with_data == ''
              assign products_with_data = product_data_string
            else
              assign products_with_data = products_with_data | append: '|||' | append: product_data_string
            endif
          endif
        endif
      endif
    endfor
    
    # Sort products alphabetically by color option value
    assign sorted_products_array = products_with_data | split: '|||'
    assign sorted_products = ''
    assign products_with_sort_keys = ''
    
    for product_item in sorted_products_array
      if product_item != blank
        assign item_parts = product_item | split: '|'
        assign sort_base_index = 0
        if item_parts.size > 0
          assign sort_first_part = item_parts[0] | strip
          if sort_first_part == blank or sort_first_part == ''
            assign sort_base_index = 1
          endif
        endif
        
        assign sort_min_size = sort_base_index | plus: 10
        if item_parts.size >= sort_min_size
          assign color_value_idx = sort_base_index | plus: 6
          assign color_value = item_parts[color_value_idx] | strip
          
          if color_value == blank or color_value == ''
            assign product_title_idx = sort_base_index | plus: 4
            if item_parts.size > product_title_idx
              assign color_value = item_parts[product_title_idx] | strip
            endif
          endif
          
          if color_value != blank and color_value != ''
            assign color_value_lower = color_value | downcase | strip
            assign sortable_item = color_value_lower | append: '|||SORT|||' | append: product_item
            if products_with_sort_keys == ''
              assign products_with_sort_keys = sortable_item
            else
              assign products_with_sort_keys = products_with_sort_keys | append: '|||SEP|||' | append: sortable_item
            endif
          endif
        endif
      endif
    endfor
    
    assign sorted_with_keys = products_with_sort_keys | split: '|||SEP|||' | sort
    
    # Deduplicate by color - only keep one product per unique color
    # Priority: current product > available variants > first variant
    assign seen_colors = ''
    assign deduplicated_products = ''
    assign current_product_color = ''
    
    # First, identify the current product's color
    assign current_variant = product_resource.selected_or_first_available_variant
    for option in product_resource.options_with_values
      assign option_name_lower = option.name | downcase
      if option_name_lower == 'color' or option_name_lower contains 'color'
        if option.position == 1
          assign current_product_color = current_variant.option1
        elsif option.position == 2
          assign current_product_color = current_variant.option2
        elsif option.position == 3
          assign current_product_color = current_variant.option3
        endif
        break
      endif
    endfor
    
    if current_product_color == blank or current_product_color == ''
      assign first_option = product_resource.options_with_values.first
      if first_option
        if first_option.position == 1
          assign current_product_color = current_variant.option1
        elsif first_option.position == 2
          assign current_product_color = current_variant.option2
        elsif first_option.position == 3
          assign current_product_color = current_variant.option3
        endif
      endif
    endif
    
    # Normalize current product color for comparison
    assign current_product_color_normalized = current_product_color | downcase | strip
    
    # First pass: collect current product if it exists
    for sorted_item in sorted_with_keys
      assign sort_parts = sorted_item | split: '|||SORT|||'
      if sort_parts.size > 1
        assign product_item_original = sort_parts[1]
        assign item_parts = product_item_original | split: '|'
        assign base_index = 0
        if item_parts.size > 0
          assign first_part = item_parts[0] | strip
          if first_part == blank or first_part == ''
            assign base_index = 1
          endif
        endif
        
        assign min_required_size = base_index | plus: 10
        if item_parts.size >= min_required_size
          assign is_current_idx = base_index | plus: 8
          assign is_current = item_parts[is_current_idx] | strip
          if is_current == 'true'
            assign color_value_idx = base_index | plus: 6
            assign color_value = item_parts[color_value_idx] | strip
            assign color_value_normalized = color_value | downcase | strip
            
            if deduplicated_products == ''
              assign deduplicated_products = product_item_original
            else
              assign deduplicated_products = deduplicated_products | append: '|||' | append: product_item_original
            endif
            
            if seen_colors == ''
              assign seen_colors = color_value_normalized
            else
              assign seen_colors = seen_colors | append: '|||' | append: color_value_normalized
            endif
          endif
        endif
      endif
    endfor
    
    # Second pass: add other products, skipping colors we've already seen
    for sorted_item in sorted_with_keys
      assign sort_parts = sorted_item | split: '|||SORT|||'
      if sort_parts.size > 1
        assign product_item_original = sort_parts[1]
        assign item_parts = product_item_original | split: '|'
        assign base_index = 0
        if item_parts.size > 0
          assign first_part = item_parts[0] | strip
          if first_part == blank or first_part == ''
            assign base_index = 1
          endif
        endif
        
        assign min_required_size = base_index | plus: 10
        if item_parts.size >= min_required_size
          assign is_current_idx = base_index | plus: 8
          assign is_current = item_parts[is_current_idx] | strip
          assign color_value_idx = base_index | plus: 6
          assign color_value = item_parts[color_value_idx] | strip
          assign color_value_normalized = color_value | downcase | strip
          assign available_idx = base_index | plus: 9
          assign variant_available = item_parts[available_idx] | strip
          
          # Skip if this is the current product (already added) or if we've seen this color
          assign color_already_seen = false
          if seen_colors != ''
            assign seen_colors_array = seen_colors | split: '|||'
            for seen_color in seen_colors_array
              if seen_color == color_value_normalized
                assign color_already_seen = true
                break
              endif
            endfor
          endif
          
          unless is_current == 'true' or color_already_seen
            # Prefer available variants, but add any variant if no available one exists for this color
            assign should_add = false
            assign variant_available_clean = variant_available | strip | downcase
            if variant_available_clean == 'true'
              # This is available, add it
              assign should_add = true
            else
              # Check if we already have an available variant for this color
              assign has_available_for_color = false
              if deduplicated_products != ''
                assign existing_products = deduplicated_products | split: '|||'
                for existing_product in existing_products
                  assign existing_parts = existing_product | split: '|'
                  assign existing_base_index = 0
                  if existing_parts.size > 0
                    assign existing_first_part = existing_parts[0] | strip
                    if existing_first_part == blank or existing_first_part == ''
                      assign existing_base_index = 1
                    endif
                  endif
                  assign existing_min_size = existing_base_index | plus: 10
                  if existing_parts.size >= existing_min_size
                    assign existing_color_idx = existing_base_index | plus: 6
                    assign existing_color = existing_parts[existing_color_idx] | strip
                    assign existing_color_normalized = existing_color | downcase | strip
                    assign existing_available_idx = existing_base_index | plus: 9
                    assign existing_available = existing_parts[existing_available_idx] | strip
                    assign existing_available_clean = existing_available | strip | downcase
                    
                    if existing_color_normalized == color_value_normalized and existing_available_clean == 'true'
                      assign has_available_for_color = true
                      break
                    endif
                  endif
                endfor
              endif
              
              # Only add if we don't have an available variant for this color yet
              unless has_available_for_color
                assign should_add = true
              endunless
            endif
            
            if should_add
              if deduplicated_products == ''
                assign deduplicated_products = product_item_original
              else
                assign deduplicated_products = deduplicated_products | append: '|||' | append: product_item_original
              endif
              
              if seen_colors == ''
                assign seen_colors = color_value_normalized
              else
                assign seen_colors = seen_colors | append: '|||' | append: color_value_normalized
              endif
            endif
          endunless
        endif
      endif
    endfor
    
    assign sorted_products = deduplicated_products
    
    # Sort swatches alphabetically by color value to match product page behavior
    if sorted_products != '' and sorted_products != blank
      assign products_to_sort = sorted_products | split: '|||'
      assign products_with_sort_keys_final = ''
      
      for product_item in products_to_sort
        if product_item != blank and product_item != ''
          assign item_parts = product_item | split: '|'
          assign sort_base_index = 0
          if item_parts.size > 0
            assign sort_first_part = item_parts[0] | strip
            if sort_first_part == blank or sort_first_part == ''
              assign sort_base_index = 1
            endif
          endif
          
          assign sort_min_size = sort_base_index | plus: 10
          if item_parts.size >= sort_min_size
            assign color_value_idx = sort_base_index | plus: 6
            assign color_value = item_parts[color_value_idx] | strip
            
            if color_value == blank or color_value == ''
              assign product_title_idx = sort_base_index | plus: 4
              if item_parts.size > product_title_idx
                assign color_value = item_parts[product_title_idx] | strip
              endif
            endif
            
            if color_value != blank and color_value != ''
              assign color_value_lower = color_value | downcase | strip
              assign sortable_item = color_value_lower | append: '|||SORT|||' | append: product_item
              if products_with_sort_keys_final == ''
                assign products_with_sort_keys_final = sortable_item
              else
                assign products_with_sort_keys_final = products_with_sort_keys_final | append: '|||SEP|||' | append: sortable_item
              endif
            endif
          endif
        endif
      endfor
      
      if products_with_sort_keys_final != '' and products_with_sort_keys_final != blank
        assign sorted_with_keys_final = products_with_sort_keys_final | split: '|||SEP|||' | sort
        assign sorted_products_final = ''
        
        for sorted_item in sorted_with_keys_final
          assign sort_parts = sorted_item | split: '|||SORT|||'
          if sort_parts.size > 1
            assign product_item_original = sort_parts[1]
            if sorted_products_final == ''
              assign sorted_products_final = product_item_original
            else
              assign sorted_products_final = sorted_products_final | append: '|||' | append: product_item_original
            endif
          endif
        endfor
        
        if sorted_products_final != '' and sorted_products_final != blank
          assign sorted_products = sorted_products_final
        endif
      endif
    endif
    
    # Make the first swatch (alphabetically first) the active one by default
    if sorted_products != '' and sorted_products != blank
      assign products_to_update = sorted_products | split: '|||'
      assign updated_products = ''
      assign first_item_processed = false
      
      for product_item in products_to_update
        if product_item != blank and product_item != ''
          assign item_parts = product_item | split: '|'
          assign base_index = 0
          if item_parts.size > 0
            assign first_part = item_parts[0] | strip
            if first_part == blank or first_part == ''
              assign base_index = 1
            endif
          endif
          
          assign min_required_size = base_index | plus: 10
          if item_parts.size >= min_required_size
            assign is_current_idx = base_index | plus: 8
            
            # Always make the first swatch active, all others false
            assign new_is_current = 'false'
            unless first_item_processed
              assign new_is_current = 'true'
              assign first_item_processed = true
            endunless
            
            # Always rebuild to ensure consistency
            assign idx0 = base_index
            assign idx1 = base_index | plus: 1
            assign idx2 = base_index | plus: 2
            assign idx3 = base_index | plus: 3
            assign idx4 = base_index | plus: 4
            assign idx5 = base_index | plus: 5
            assign idx6 = base_index | plus: 6
            assign idx7 = base_index | plus: 7
            assign idx9 = base_index | plus: 9
            
            assign updated_product_item = item_parts[idx0]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx1]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx2]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx3]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx4]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx5]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx6]
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx7]
            assign updated_product_item = updated_product_item | append: '|' | append: new_is_current
            assign updated_product_item = updated_product_item | append: '|' | append: item_parts[idx9]
            
            # Include leading blank if base_index is 1
            if base_index == 1
              assign updated_product_item = item_parts[0] | append: '|' | append: updated_product_item
            endif
            
            if updated_products == ''
              assign updated_products = updated_product_item
            else
              assign updated_products = updated_products | append: '|||' | append: updated_product_item
            endif
          else
            # If item doesn't have required size, add as-is
            if updated_products == ''
              assign updated_products = product_item
            else
              assign updated_products = updated_products | append: '|||' | append: product_item
            endif
          endif
        endif
      endfor
      
      if updated_products != '' and updated_products != blank
        assign sorted_products = updated_products
      endif
    endif
    
      # Set output variable
      assign sorted_swatches_data = sorted_products
    endif
    
    # Extract first variant data for product card image/URL
    if has_combined_listing and sorted_swatches_data != '' and sorted_swatches_data != blank
      assign first_swatch_data = sorted_swatches_data | split: '|||' | first
      if first_swatch_data != blank
        assign first_parts = first_swatch_data | split: '|'
        assign first_base_index = 0
        if first_parts.size > 0
          assign first_first_part = first_parts[0] | strip
          if first_first_part == blank or first_first_part == ''
            assign first_base_index = 1
          endif
        endif
        
        assign first_min_size = first_base_index | plus: 10
        if first_parts.size >= first_min_size
          assign first_product_id_idx = first_base_index
          assign first_variant_id_idx = first_base_index | plus: 2
          assign first_product_id = first_parts[first_product_id_idx] | strip
          assign first_variant_id = first_parts[first_variant_id_idx] | strip
          
          assign first_product_id_as_number = first_product_id | plus: 0
          assign first_variant_id_as_number = first_variant_id | plus: 0
          
          # Find the product and variant
          # Reset to blank first (don't use existing value)
          assign first_product_obj = blank
          if combined_listings_metafield != blank and combined_listings_metafield.value != blank
            for linked_product in combined_listings_metafield.value
              assign linked_product_id = linked_product.id
              assign linked_product_id_as_string = linked_product_id | append: ''
              if linked_product_id == first_product_id or linked_product_id == first_product_id_as_number or linked_product_id_as_string == first_product_id
                assign first_product_obj = linked_product
                break
              endif
            endfor
          endif
          
          if first_product_obj == blank
            if first_product_id == product_resource.id or first_product_id_as_number == product_resource.id
              assign first_product_obj = product_resource
            else
              for all_product in collections.all.products
                assign all_product_id_as_string = all_product.id | append: ''
                if all_product.id == first_product_id or all_product.id == first_product_id_as_number or all_product_id_as_string == first_product_id
                  assign first_product_obj = all_product
                  break
                endif
              endfor
            endif
          endif
          
          if first_product_obj != ''
            for variant in first_product_obj.variants
              assign variant_id_str = variant.id | append: ''
              if variant.id == first_variant_id or variant.id == first_variant_id_as_number or variant_id_str == first_variant_id
                assign first_variant = variant
                break
              endif
            endfor
            
            if first_variant != blank
              if first_variant.featured_image != blank
                assign first_variant_image = first_variant.featured_image
              elsif first_product_obj.featured_media != blank
                assign first_variant_image = first_product_obj.featured_media
              endif
              
              assign first_variant_url = first_variant.url
              unless first_variant_url
                assign first_variant_url = first_product_obj.url
              endunless
            endif
          endif
        endif
      endif
    endif
  endif
%}

{%- comment -%}
  CRITICAL: Variables set inside {% liquid %} blocks may not persist to calling context.
  We need to explicitly output/assign them outside the liquid block to ensure they're accessible.
  Using assign statements outside the liquid block to ensure variable persistence.
{%- endcomment -%}
{% assign has_combined_listing = has_combined_listing %}
{% assign sorted_swatches_data = sorted_swatches_data %}
{% assign first_variant = first_variant %}
{% assign first_variant_image = first_variant_image %}
{% assign first_variant_url = first_variant_url %}

